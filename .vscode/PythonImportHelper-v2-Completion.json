[
    {
        "label": "io",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "io",
        "description": "io",
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "urlparse",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "BeautifulSoup",
        "importPath": "bs4",
        "description": "bs4",
        "isExtraImport": true,
        "detail": "bs4",
        "documentation": {}
    },
    {
        "label": "PdfReader",
        "importPath": "PyPDF2",
        "description": "PyPDF2",
        "isExtraImport": true,
        "detail": "PyPDF2",
        "documentation": {}
    },
    {
        "label": "scrapy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "scrapy",
        "description": "scrapy",
        "detail": "scrapy",
        "documentation": {}
    },
    {
        "label": "scrapy.crawler",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "scrapy.crawler",
        "description": "scrapy.crawler",
        "detail": "scrapy.crawler",
        "documentation": {}
    },
    {
        "label": "configure_logging",
        "importPath": "scrapy.utils.log",
        "description": "scrapy.utils.log",
        "isExtraImport": true,
        "detail": "scrapy.utils.log",
        "documentation": {}
    },
    {
        "label": "reactor",
        "importPath": "twisted.internet",
        "description": "twisted.internet",
        "isExtraImport": true,
        "detail": "twisted.internet",
        "documentation": {}
    },
    {
        "label": "Process",
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "isExtraImport": true,
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "Queue",
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "isExtraImport": true,
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "EncryptedCookieManager",
        "importPath": "streamlit_cookies_manager",
        "description": "streamlit_cookies_manager",
        "isExtraImport": true,
        "detail": "streamlit_cookies_manager",
        "documentation": {}
    },
    {
        "label": "EncryptedCookieManager",
        "importPath": "streamlit_cookies_manager",
        "description": "streamlit_cookies_manager",
        "isExtraImport": true,
        "detail": "streamlit_cookies_manager",
        "documentation": {}
    },
    {
        "label": "streamlit",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "streamlit",
        "description": "streamlit",
        "detail": "streamlit",
        "documentation": {}
    },
    {
        "label": "pymongo",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pymongo",
        "description": "pymongo",
        "detail": "pymongo",
        "documentation": {}
    },
    {
        "label": "run_scrapy_chatbot_version",
        "importPath": "Scraping.Scraping",
        "description": "Scraping.Scraping",
        "isExtraImport": true,
        "detail": "Scraping.Scraping",
        "documentation": {}
    },
    {
        "label": "run_scrapy_chatbot_version",
        "importPath": "Scraping.Scraping",
        "description": "Scraping.Scraping",
        "isExtraImport": true,
        "detail": "Scraping.Scraping",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "ObjectId",
        "importPath": "bson",
        "description": "bson",
        "isExtraImport": true,
        "detail": "bson",
        "documentation": {}
    },
    {
        "label": "generate_chatbot_version",
        "importPath": "functions.utils_chatbot",
        "description": "functions.utils_chatbot",
        "isExtraImport": true,
        "detail": "functions.utils_chatbot",
        "documentation": {}
    },
    {
        "label": "check_unique_telegram_key",
        "importPath": "functions.utils_chatbot",
        "description": "functions.utils_chatbot",
        "isExtraImport": true,
        "detail": "functions.utils_chatbot",
        "documentation": {}
    },
    {
        "label": "save_new_chatbot",
        "importPath": "functions.utils_chatbot",
        "description": "functions.utils_chatbot",
        "isExtraImport": true,
        "detail": "functions.utils_chatbot",
        "documentation": {}
    },
    {
        "label": "generate_chatbot_version",
        "importPath": "functions.utils_chatbot",
        "description": "functions.utils_chatbot",
        "isExtraImport": true,
        "detail": "functions.utils_chatbot",
        "documentation": {}
    },
    {
        "label": "upload_chatbot_version",
        "importPath": "functions.utils_chatbot",
        "description": "functions.utils_chatbot",
        "isExtraImport": true,
        "detail": "functions.utils_chatbot",
        "documentation": {}
    },
    {
        "label": "Courier",
        "importPath": "trycourier",
        "description": "trycourier",
        "isExtraImport": true,
        "detail": "trycourier",
        "documentation": {}
    },
    {
        "label": "secrets",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "secrets",
        "description": "secrets",
        "detail": "secrets",
        "documentation": {}
    },
    {
        "label": "PasswordHasher",
        "importPath": "argon2",
        "description": "argon2",
        "isExtraImport": true,
        "detail": "argon2",
        "documentation": {}
    },
    {
        "label": "requests",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "requests",
        "description": "requests",
        "detail": "requests",
        "documentation": {}
    },
    {
        "label": "st_lottie",
        "importPath": "streamlit_lottie",
        "description": "streamlit_lottie",
        "isExtraImport": true,
        "detail": "streamlit_lottie",
        "documentation": {}
    },
    {
        "label": "option_menu",
        "importPath": "streamlit_option_menu",
        "description": "streamlit_option_menu",
        "isExtraImport": true,
        "detail": "streamlit_option_menu",
        "documentation": {}
    },
    {
        "label": "switch_page",
        "importPath": "streamlit_extras.switch_page_button",
        "description": "streamlit_extras.switch_page_button",
        "isExtraImport": true,
        "detail": "streamlit_extras.switch_page_button",
        "documentation": {}
    },
    {
        "label": "switch_page",
        "importPath": "streamlit_extras.switch_page_button",
        "description": "streamlit_extras.switch_page_button",
        "isExtraImport": true,
        "detail": "streamlit_extras.switch_page_button",
        "documentation": {}
    },
    {
        "label": "switch_page",
        "importPath": "streamlit_extras.switch_page_button",
        "description": "streamlit_extras.switch_page_button",
        "isExtraImport": true,
        "detail": "streamlit_extras.switch_page_button",
        "documentation": {}
    },
    {
        "label": "get_decrypted_cookie",
        "importPath": "functions.utils",
        "description": "functions.utils",
        "isExtraImport": true,
        "detail": "functions.utils",
        "documentation": {}
    },
    {
        "label": "show_logout",
        "importPath": "functions.utils",
        "description": "functions.utils",
        "isExtraImport": true,
        "detail": "functions.utils",
        "documentation": {}
    },
    {
        "label": "get_decrypted_cookie",
        "importPath": "functions.utils",
        "description": "functions.utils",
        "isExtraImport": true,
        "detail": "functions.utils",
        "documentation": {}
    },
    {
        "label": "show_logout",
        "importPath": "functions.utils",
        "description": "functions.utils",
        "isExtraImport": true,
        "detail": "functions.utils",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "activate_version_by_id",
        "importPath": "functions.utils_home",
        "description": "functions.utils_home",
        "isExtraImport": true,
        "detail": "functions.utils_home",
        "documentation": {}
    },
    {
        "label": "get_user_chatbots",
        "importPath": "functions.utils_home",
        "description": "functions.utils_home",
        "isExtraImport": true,
        "detail": "functions.utils_home",
        "documentation": {}
    },
    {
        "label": "update_chatbot_version",
        "importPath": "functions.utils_home",
        "description": "functions.utils_home",
        "isExtraImport": true,
        "detail": "functions.utils_home",
        "documentation": {}
    },
    {
        "label": "delete_version_by_id",
        "importPath": "functions.utils_home",
        "description": "functions.utils_home",
        "isExtraImport": true,
        "detail": "functions.utils_home",
        "documentation": {}
    },
    {
        "label": "__login__",
        "importPath": "packages.streamlit_login.widgets",
        "description": "packages.streamlit_login.widgets",
        "isExtraImport": true,
        "detail": "packages.streamlit_login.widgets",
        "documentation": {}
    },
    {
        "label": "IfbSpider",
        "kind": 6,
        "importPath": "Scraping.Scraping",
        "description": "Scraping.Scraping",
        "peekOfCode": "class IfbSpider(scrapy.Spider):\n    name = \"ifb_spider\"\n    start_urls = []\n    custom_settings = {\n        \"DEPTH_LIMIT\": 2,\n        \"DOWNLOAD_DELAY\": 0.5,\n    }\n    accepted_files = [\"pdf\"]\n    allowed_domains = []\n    content_element = \"#content\"",
        "detail": "Scraping.Scraping",
        "documentation": {}
    },
    {
        "label": "run_scrapy_chatbot_version",
        "kind": 2,
        "importPath": "Scraping.Scraping",
        "description": "Scraping.Scraping",
        "peekOfCode": "def run_scrapy_chatbot_version(start_urls, depth_limit, download_delay, accepted_files, allowed_domains, content_element, result_file_path):\n    def f(q):\n        try:\n            IfbSpider.set_spider_params(start_urls, depth_limit, download_delay, accepted_files, allowed_domains, content_element, result_file_path)\n            runner = crawler.CrawlerRunner()\n            deferred = runner.crawl(IfbSpider)\n            deferred.addBoth(lambda _: reactor.stop())\n            reactor.run()\n            q.put(None)\n        except Exception as e:",
        "detail": "Scraping.Scraping",
        "documentation": {}
    },
    {
        "label": "Utils",
        "kind": 6,
        "importPath": "functions.utils",
        "description": "functions.utils",
        "peekOfCode": "class Utils:\n    def __init__(self):\n        # Configura√ß√£o do EncryptedCookieManager\n        self.cookies = EncryptedCookieManager(\n            prefix=\"streamlit_login_ui_yummy_cookies\",\n            password='9d68d6f2-4258-45c9-96eb-2d6bc74ddbb5-d8f49cab-edbb-404a-94d0-b25b1d4a564b'\n        )\n        if not self.cookies.ready():\n            st.stop()  \n    def get_decrypted_cookie(self, cookie_name):",
        "detail": "functions.utils",
        "documentation": {}
    },
    {
        "label": "utils_instance",
        "kind": 5,
        "importPath": "functions.utils",
        "description": "functions.utils",
        "peekOfCode": "utils_instance = Utils()\n# Ao importar utils.py diretamente, utils_instance est√° dispon√≠vel imediatamente\nget_decrypted_cookie = utils_instance.get_decrypted_cookie\nshow_logout = utils_instance.show_logout",
        "detail": "functions.utils",
        "documentation": {}
    },
    {
        "label": "get_decrypted_cookie",
        "kind": 5,
        "importPath": "functions.utils",
        "description": "functions.utils",
        "peekOfCode": "get_decrypted_cookie = utils_instance.get_decrypted_cookie\nshow_logout = utils_instance.show_logout",
        "detail": "functions.utils",
        "documentation": {}
    },
    {
        "label": "show_logout",
        "kind": 5,
        "importPath": "functions.utils",
        "description": "functions.utils",
        "peekOfCode": "show_logout = utils_instance.show_logout",
        "detail": "functions.utils",
        "documentation": {}
    },
    {
        "label": "init_connection",
        "kind": 2,
        "importPath": "functions.utils_chatbot",
        "description": "functions.utils_chatbot",
        "peekOfCode": "def init_connection():\n    client = pymongo.MongoClient(st.secrets[\"mongo\"][\"url\"])\n    db = client.TCC\n    return db\ndb = init_connection()\nchatbots_collection = db.chatbots\nversions_collection = db.chatbot_versions\ndef check_unique_telegram_key(telegram_key: str) -> bool:\n    return True\ndef save_new_chatbot(",
        "detail": "functions.utils_chatbot",
        "documentation": {}
    },
    {
        "label": "check_unique_telegram_key",
        "kind": 2,
        "importPath": "functions.utils_chatbot",
        "description": "functions.utils_chatbot",
        "peekOfCode": "def check_unique_telegram_key(telegram_key: str) -> bool:\n    return True\ndef save_new_chatbot(\n    chatbot_name,\n    telegram_api_key,\n    chatbot_description,\n    start_url,\n    allowed_domains,\n    allowed_files,\n    content_element,",
        "detail": "functions.utils_chatbot",
        "documentation": {}
    },
    {
        "label": "save_new_chatbot",
        "kind": 2,
        "importPath": "functions.utils_chatbot",
        "description": "functions.utils_chatbot",
        "peekOfCode": "def save_new_chatbot(\n    chatbot_name,\n    telegram_api_key,\n    chatbot_description,\n    start_url,\n    allowed_domains,\n    allowed_files,\n    content_element,\n    requests_delay_ms,\n    max_assync_requests,",
        "detail": "functions.utils_chatbot",
        "documentation": {}
    },
    {
        "label": "get_chatbot_info",
        "kind": 2,
        "importPath": "functions.utils_chatbot",
        "description": "functions.utils_chatbot",
        "peekOfCode": "def get_chatbot_info(bot_id):\n    try:\n        print(bot_id)\n        chatbot_info = chatbots_collection.find_one({\"_id\": bot_id})\n        return chatbot_info\n    except Exception as e:\n        print(f\"Erro ao buscar informa√ß√µes do chatbot no MongoDB: {e}\")\n        return None\ndef generate_chatbot_version(bot_id, version_name):\n    # Busque as informa√ß√µes do chatbot no MongoDB",
        "detail": "functions.utils_chatbot",
        "documentation": {}
    },
    {
        "label": "generate_chatbot_version",
        "kind": 2,
        "importPath": "functions.utils_chatbot",
        "description": "functions.utils_chatbot",
        "peekOfCode": "def generate_chatbot_version(bot_id, version_name):\n    # Busque as informa√ß√µes do chatbot no MongoDB\n    try:\n        chatbot_info = get_chatbot_info(bot_id)\n        chatbot_name = chatbot_info.get(\"chatbot_name\")\n        if chatbot_info:\n            start_urls = [chatbot_info.get(\"start_url\")]\n            accepted_files = chatbot_info.get(\"allowed_files\")\n            allowed_domains = chatbot_info.get(\"allowed_domains\")\n            depth_limit = chatbot_info.get(\"depth_limit\")",
        "detail": "functions.utils_chatbot",
        "documentation": {}
    },
    {
        "label": "upload_chatbot_version",
        "kind": 2,
        "importPath": "functions.utils_chatbot",
        "description": "functions.utils_chatbot",
        "peekOfCode": "def upload_chatbot_version(chatbot_id,version_id, file_path):\n    try:\n        # Ler o conte√∫do do arquivo\n        with open(file_path, \"r\") as file:\n            content = file.read()\n        # Criar a estrutura de dados\n        data = {\n            \"chatbot_id\": chatbot_id,\n            \"version_id\": version_id,\n            \"created_at\": datetime.now(),",
        "detail": "functions.utils_chatbot",
        "documentation": {}
    },
    {
        "label": "db",
        "kind": 5,
        "importPath": "functions.utils_chatbot",
        "description": "functions.utils_chatbot",
        "peekOfCode": "db = init_connection()\nchatbots_collection = db.chatbots\nversions_collection = db.chatbot_versions\ndef check_unique_telegram_key(telegram_key: str) -> bool:\n    return True\ndef save_new_chatbot(\n    chatbot_name,\n    telegram_api_key,\n    chatbot_description,\n    start_url,",
        "detail": "functions.utils_chatbot",
        "documentation": {}
    },
    {
        "label": "chatbots_collection",
        "kind": 5,
        "importPath": "functions.utils_chatbot",
        "description": "functions.utils_chatbot",
        "peekOfCode": "chatbots_collection = db.chatbots\nversions_collection = db.chatbot_versions\ndef check_unique_telegram_key(telegram_key: str) -> bool:\n    return True\ndef save_new_chatbot(\n    chatbot_name,\n    telegram_api_key,\n    chatbot_description,\n    start_url,\n    allowed_domains,",
        "detail": "functions.utils_chatbot",
        "documentation": {}
    },
    {
        "label": "versions_collection",
        "kind": 5,
        "importPath": "functions.utils_chatbot",
        "description": "functions.utils_chatbot",
        "peekOfCode": "versions_collection = db.chatbot_versions\ndef check_unique_telegram_key(telegram_key: str) -> bool:\n    return True\ndef save_new_chatbot(\n    chatbot_name,\n    telegram_api_key,\n    chatbot_description,\n    start_url,\n    allowed_domains,\n    allowed_files,",
        "detail": "functions.utils_chatbot",
        "documentation": {}
    },
    {
        "label": "init_connection",
        "kind": 2,
        "importPath": "functions.utils_home",
        "description": "functions.utils_home",
        "peekOfCode": "def init_connection():\n    client = pymongo.MongoClient(st.secrets[\"mongo\"][\"url\"])\n    db = client.TCC\n    return db\ndb = init_connection()\nchatbots_collection = db.chatbots\nversions_collection = db.chatbot_versions\ndef get_user_chatbots(user_id):\n    try:\n        user_chatbots = chatbots_collection.find({\"UserIds\": user_id})",
        "detail": "functions.utils_home",
        "documentation": {}
    },
    {
        "label": "get_user_chatbots",
        "kind": 2,
        "importPath": "functions.utils_home",
        "description": "functions.utils_home",
        "peekOfCode": "def get_user_chatbots(user_id):\n    try:\n        user_chatbots = chatbots_collection.find({\"UserIds\": user_id})\n        user_list = list(user_chatbots)\n         # Para cada chatbot do usu√°rio, busca as vers√µes e adiciona ao campo \"versions\"\n        for chatbot in user_list:\n            chatbot_id = ObjectId(chatbot[\"_id\"])\n            versions = list(versions_collection.find({\"chatbot_id\": chatbot_id}, {\"_id\": 1, \"chatbot_id\": 1, \"version_id\": 1, \"created_at\": 1}).sort(\"created_at\", pymongo.DESCENDING))\n            chatbot[\"versions\"] = versions\n        return user_list",
        "detail": "functions.utils_home",
        "documentation": {}
    },
    {
        "label": "activate_version_by_id",
        "kind": 2,
        "importPath": "functions.utils_home",
        "description": "functions.utils_home",
        "peekOfCode": "def activate_version_by_id(version_id_db):\n    try:\n        # Encontrar a vers√£o pelo ID\n        version = versions_collection.find_one({\"_id\": version_id_db})\n        if version:\n            # Atualizar o campo 'actual_version' na collection de chatbots\n            chatbots_collection.update_one({\"_id\": version[\"chatbot_id\"]}, {\"$set\": {\"active_version\": version[\"version_id\"]}})\n            #st.success(f\"Vers√£o ativada com sucesso para o Chatbot de ID: {version['chatbot_id']}\")\n            #TODO ADICIONAR REQUEST API PARA BUSCAR NOVAMENTE A VERS√ÉO NO MONGO\n            return True",
        "detail": "functions.utils_home",
        "documentation": {}
    },
    {
        "label": "delete_version_by_id",
        "kind": 2,
        "importPath": "functions.utils_home",
        "description": "functions.utils_home",
        "peekOfCode": "def delete_version_by_id(version_id_db):\n    try:\n        # Encontrar a vers√£o pelo ID\n        version = versions_collection.find_one({\"_id\": version_id_db})\n        if version:\n            # Excluir a vers√£o da collection de vers√µes\n            versions_collection.delete_one({\"_id\": version_id_db})\n            return True\n        else:\n            st.warning(f\"Vers√£o com ID {version_id_db} n√£o encontrada.\")",
        "detail": "functions.utils_home",
        "documentation": {}
    },
    {
        "label": "update_chatbot_version",
        "kind": 2,
        "importPath": "functions.utils_home",
        "description": "functions.utils_home",
        "peekOfCode": "def update_chatbot_version(chatbot_id):\n    try:\n        # Buscar as vers√µes do bot ordenadas por ordem decrescente pela data de cria√ß√£o\n        versions = list(versions_collection.find({\"chatbot_id\": ObjectId(chatbot_id)}, {\"_id\": 1, \"version_id\": 1, \"created_at\": 1}).sort(\"created_at\", pymongo.DESCENDING))\n        if versions:\n            # Obter o n√∫mero da √∫ltima vers√£o e incrementar 1\n            last_version_number = int(versions[0][\"version_id\"].split(\".\")[0])\n            new_version_number = f\"{last_version_number + 1}.0\"\n            # Chamar a fun√ß√£o para gerar a nova vers√£o\n            generate_chatbot_version(ObjectId(chatbot_id), new_version_number)",
        "detail": "functions.utils_home",
        "documentation": {}
    },
    {
        "label": "db",
        "kind": 5,
        "importPath": "functions.utils_home",
        "description": "functions.utils_home",
        "peekOfCode": "db = init_connection()\nchatbots_collection = db.chatbots\nversions_collection = db.chatbot_versions\ndef get_user_chatbots(user_id):\n    try:\n        user_chatbots = chatbots_collection.find({\"UserIds\": user_id})\n        user_list = list(user_chatbots)\n         # Para cada chatbot do usu√°rio, busca as vers√µes e adiciona ao campo \"versions\"\n        for chatbot in user_list:\n            chatbot_id = ObjectId(chatbot[\"_id\"])",
        "detail": "functions.utils_home",
        "documentation": {}
    },
    {
        "label": "chatbots_collection",
        "kind": 5,
        "importPath": "functions.utils_home",
        "description": "functions.utils_home",
        "peekOfCode": "chatbots_collection = db.chatbots\nversions_collection = db.chatbot_versions\ndef get_user_chatbots(user_id):\n    try:\n        user_chatbots = chatbots_collection.find({\"UserIds\": user_id})\n        user_list = list(user_chatbots)\n         # Para cada chatbot do usu√°rio, busca as vers√µes e adiciona ao campo \"versions\"\n        for chatbot in user_list:\n            chatbot_id = ObjectId(chatbot[\"_id\"])\n            versions = list(versions_collection.find({\"chatbot_id\": chatbot_id}, {\"_id\": 1, \"chatbot_id\": 1, \"version_id\": 1, \"created_at\": 1}).sort(\"created_at\", pymongo.DESCENDING))",
        "detail": "functions.utils_home",
        "documentation": {}
    },
    {
        "label": "versions_collection",
        "kind": 5,
        "importPath": "functions.utils_home",
        "description": "functions.utils_home",
        "peekOfCode": "versions_collection = db.chatbot_versions\ndef get_user_chatbots(user_id):\n    try:\n        user_chatbots = chatbots_collection.find({\"UserIds\": user_id})\n        user_list = list(user_chatbots)\n         # Para cada chatbot do usu√°rio, busca as vers√µes e adiciona ao campo \"versions\"\n        for chatbot in user_list:\n            chatbot_id = ObjectId(chatbot[\"_id\"])\n            versions = list(versions_collection.find({\"chatbot_id\": chatbot_id}, {\"_id\": 1, \"chatbot_id\": 1, \"version_id\": 1, \"created_at\": 1}).sort(\"created_at\", pymongo.DESCENDING))\n            chatbot[\"versions\"] = versions",
        "detail": "functions.utils_home",
        "documentation": {}
    },
    {
        "label": "init_connection",
        "kind": 2,
        "importPath": "packages.streamlit_login.utils",
        "description": "packages.streamlit_login.utils",
        "peekOfCode": "def init_connection():\n    client = pymongo.MongoClient(st.secrets[\"mongo\"][\"url\"])\n    db = client.TCC\n    return db.users\ncollection = init_connection()\nph = PasswordHasher() \ndef check_usr_pass(username: str, password: str):\n    \"\"\"\n    Authenticates the username and password.\n    \"\"\"",
        "detail": "packages.streamlit_login.utils",
        "documentation": {}
    },
    {
        "label": "check_usr_pass",
        "kind": 2,
        "importPath": "packages.streamlit_login.utils",
        "description": "packages.streamlit_login.utils",
        "peekOfCode": "def check_usr_pass(username: str, password: str):\n    \"\"\"\n    Authenticates the username and password.\n    \"\"\"\n    user = collection.find_one({\"username\": username})\n    if user:\n        try:\n            if ph.verify(user['password'], password):\n                return {\"success\": True, \"userId\": str(user['_id'])}\n        except Exception as e:",
        "detail": "packages.streamlit_login.utils",
        "documentation": {}
    },
    {
        "label": "load_lottieurl",
        "kind": 2,
        "importPath": "packages.streamlit_login.utils",
        "description": "packages.streamlit_login.utils",
        "peekOfCode": "def load_lottieurl(url: str) -> str:\n    \"\"\"\n    Fetches the lottie animation using the URL.\n    \"\"\"\n    try:\n        r = requests.get(url)\n        if r.status_code != 200:\n            return None\n        return r.json()\n    except:",
        "detail": "packages.streamlit_login.utils",
        "documentation": {}
    },
    {
        "label": "check_valid_name",
        "kind": 2,
        "importPath": "packages.streamlit_login.utils",
        "description": "packages.streamlit_login.utils",
        "peekOfCode": "def check_valid_name(name_sign_up: str) -> bool:\n    \"\"\"\n    Checks if the user entered a valid name while creating the account.\n    \"\"\"\n    name_regex = (r'^[A-Za-z_][A-Za-z0-9_]*')\n    if re.search(name_regex, name_sign_up):\n        return True\n    return False\ndef check_valid_email(email_sign_up: str) -> bool:\n    \"\"\"",
        "detail": "packages.streamlit_login.utils",
        "documentation": {}
    },
    {
        "label": "check_valid_email",
        "kind": 2,
        "importPath": "packages.streamlit_login.utils",
        "description": "packages.streamlit_login.utils",
        "peekOfCode": "def check_valid_email(email_sign_up: str) -> bool:\n    \"\"\"\n    Checks if the user entered a valid email while creating the account.\n    \"\"\"\n    regex = re.compile(r'([A-Za-z0-9]+[.-_])*[A-Za-z0-9]+@[A-Za-z0-9-]+(\\.[A-Z|a-z]{2,})+')\n    if re.fullmatch(regex, email_sign_up):\n        return True\n    return False\ndef check_unique_email(email_sign_up: str) -> bool:\n    \"\"\"",
        "detail": "packages.streamlit_login.utils",
        "documentation": {}
    },
    {
        "label": "check_unique_email",
        "kind": 2,
        "importPath": "packages.streamlit_login.utils",
        "description": "packages.streamlit_login.utils",
        "peekOfCode": "def check_unique_email(email_sign_up: str) -> bool:\n    \"\"\"\n    Checks if the email already exists (since email needs to be unique).\n    \"\"\"\n    user = collection.find_one({\"email\": email_sign_up})\n    return not user\ndef non_empty_str_check(username_sign_up: str) -> bool:\n    \"\"\"\n    Checks for non-empty strings.\n    \"\"\"",
        "detail": "packages.streamlit_login.utils",
        "documentation": {}
    },
    {
        "label": "non_empty_str_check",
        "kind": 2,
        "importPath": "packages.streamlit_login.utils",
        "description": "packages.streamlit_login.utils",
        "peekOfCode": "def non_empty_str_check(username_sign_up: str) -> bool:\n    \"\"\"\n    Checks for non-empty strings.\n    \"\"\"\n    empty_count = 0\n    for i in username_sign_up:\n        if i == ' ':\n            empty_count = empty_count + 1\n            if empty_count == len(username_sign_up):\n                return False",
        "detail": "packages.streamlit_login.utils",
        "documentation": {}
    },
    {
        "label": "check_unique_usr",
        "kind": 2,
        "importPath": "packages.streamlit_login.utils",
        "description": "packages.streamlit_login.utils",
        "peekOfCode": "def check_unique_usr(username_sign_up: str):\n    \"\"\"\n    Checks if the username already exists (since username needs to be unique),\n    also checks for non - empty username.\n    \"\"\"\n    user = collection.find_one({\"username\": username_sign_up})\n    if user:\n        return False\n    non_empty_check = non_empty_str_check(username_sign_up)\n    if not non_empty_check:",
        "detail": "packages.streamlit_login.utils",
        "documentation": {}
    },
    {
        "label": "register_new_usr",
        "kind": 2,
        "importPath": "packages.streamlit_login.utils",
        "description": "packages.streamlit_login.utils",
        "peekOfCode": "def register_new_usr(name_sign_up: str, email_sign_up: str, username_sign_up: str, password_sign_up: str) -> None:\n    \"\"\"\n    Saves the information of the new user in the _secret_auth.json file.\n    \"\"\"\n    new_usr_data = {\n        'username': username_sign_up,\n        'name': name_sign_up,\n        'email': email_sign_up,\n        'password': ph.hash(password_sign_up)\n    }",
        "detail": "packages.streamlit_login.utils",
        "documentation": {}
    },
    {
        "label": "check_email_exists",
        "kind": 2,
        "importPath": "packages.streamlit_login.utils",
        "description": "packages.streamlit_login.utils",
        "peekOfCode": "def check_email_exists(email_forgot_passwd: str):\n    \"\"\"\n    Checks if the email entered is present in the _secret_auth.json file.\n    \"\"\"\n    user = collection.find_one({\"email\": email_forgot_passwd})\n    if user:\n        return True, user['username']\n    return False, None\ndef generate_random_passwd() -> str:\n    \"\"\"",
        "detail": "packages.streamlit_login.utils",
        "documentation": {}
    },
    {
        "label": "generate_random_passwd",
        "kind": 2,
        "importPath": "packages.streamlit_login.utils",
        "description": "packages.streamlit_login.utils",
        "peekOfCode": "def generate_random_passwd() -> str:\n    \"\"\"\n    Generates a random password to be sent in email.\n    \"\"\"\n    password_length = 10\n    return secrets.token_urlsafe(password_length)\ndef send_passwd_in_email(auth_token: str, username_forgot_passwd: str, email_forgot_passwd: str, company_name: str, random_password: str, reset_url: str) -> None:\n    \"\"\"\n    Triggers an email to the user containing the randomly generated password.\n    \"\"\"",
        "detail": "packages.streamlit_login.utils",
        "documentation": {}
    },
    {
        "label": "send_passwd_in_email",
        "kind": 2,
        "importPath": "packages.streamlit_login.utils",
        "description": "packages.streamlit_login.utils",
        "peekOfCode": "def send_passwd_in_email(auth_token: str, username_forgot_passwd: str, email_forgot_passwd: str, company_name: str, random_password: str, reset_url: str) -> None:\n    \"\"\"\n    Triggers an email to the user containing the randomly generated password.\n    \"\"\"\n    client = Courier(auth_token = auth_token)\n    resp = client.send_message(\n    message={\n        \"to\": {\n        \"email\": email_forgot_passwd\n        },",
        "detail": "packages.streamlit_login.utils",
        "documentation": {}
    },
    {
        "label": "change_passwd",
        "kind": 2,
        "importPath": "packages.streamlit_login.utils",
        "description": "packages.streamlit_login.utils",
        "peekOfCode": "def change_passwd(email_: str, random_password: str) -> None:\n    \"\"\"\n    Replaces the old password with the newly generated password.\n    \"\"\"\n    user = collection.find_one({\"email\": email_})\n    if user:\n        user['password'] = ph.hash(random_password)\n        collection.update_one({\"_id\": user[\"_id\"]}, {\"$set\": user})\ndef check_current_passwd(email_reset_passwd: str, current_passwd: str) -> bool:\n    \"\"\"",
        "detail": "packages.streamlit_login.utils",
        "documentation": {}
    },
    {
        "label": "check_current_passwd",
        "kind": 2,
        "importPath": "packages.streamlit_login.utils",
        "description": "packages.streamlit_login.utils",
        "peekOfCode": "def check_current_passwd(email_reset_passwd: str, current_passwd: str) -> bool:\n    \"\"\"\n    Authenticates the password entered against the username when \n    resetting the password.\n    \"\"\"\n    user = collection.find_one({\"email\": email_reset_passwd})\n    if user:\n        try:\n            if ph.verify(user['password'], current_passwd):\n                return True",
        "detail": "packages.streamlit_login.utils",
        "documentation": {}
    },
    {
        "label": "collection",
        "kind": 5,
        "importPath": "packages.streamlit_login.utils",
        "description": "packages.streamlit_login.utils",
        "peekOfCode": "collection = init_connection()\nph = PasswordHasher() \ndef check_usr_pass(username: str, password: str):\n    \"\"\"\n    Authenticates the username and password.\n    \"\"\"\n    user = collection.find_one({\"username\": username})\n    if user:\n        try:\n            if ph.verify(user['password'], password):",
        "detail": "packages.streamlit_login.utils",
        "documentation": {}
    },
    {
        "label": "ph",
        "kind": 5,
        "importPath": "packages.streamlit_login.utils",
        "description": "packages.streamlit_login.utils",
        "peekOfCode": "ph = PasswordHasher() \ndef check_usr_pass(username: str, password: str):\n    \"\"\"\n    Authenticates the username and password.\n    \"\"\"\n    user = collection.find_one({\"username\": username})\n    if user:\n        try:\n            if ph.verify(user['password'], password):\n                return {\"success\": True, \"userId\": str(user['_id'])}",
        "detail": "packages.streamlit_login.utils",
        "documentation": {}
    },
    {
        "label": "__login__",
        "kind": 6,
        "importPath": "packages.streamlit_login.widgets",
        "description": "packages.streamlit_login.widgets",
        "peekOfCode": "class __login__:\n    \"\"\"\n    Builds the UI for the Login/ Sign Up page.\n    \"\"\"\n    def __init__(self, auth_token: str, company_name: str, width, height, logout_button_name: str = 'Logout', hide_menu_bool: bool = False, hide_footer_bool: bool = False, hide_sidebar_itens_bool: bool = False, lottie_url: str = \"https://assets8.lottiefiles.com/packages/lf20_ktwnwv5m.json\", password_reset_url: str = ''):\n        \"\"\"\n        Arguments:\n        -----------\n        1. self\n        2. auth_token : The unique authorization token received from - https://www.courier.com/email-api/",
        "detail": "packages.streamlit_login.widgets",
        "documentation": {}
    },
    {
        "label": "create_bot_widget",
        "kind": 2,
        "importPath": "pages.Criar_bot",
        "description": "pages.Criar_bot",
        "peekOfCode": "def create_bot_widget():\n    st.title(\"Criar bot\")\n    # Campo para o nome do bot\n    chatbot_name = st.text_input(\"Nome do Bot\")\n    # Campo para a API KEY do Telegram\n    api_key_telegram = st.text_input(\"API KEY Telegram\", help=\"Obtenha a API KEY no site de documenta√ß√£o.\")\n    check_unique_telegram_key(api_key_telegram)\n    # Campo de descri√ß√£o do bot (text area)\n    chatbot_description = st.text_area(\"Descri√ß√£o\")\n    st.divider() ",
        "detail": "pages.Criar_bot",
        "documentation": {}
    },
    {
        "label": "userId",
        "kind": 5,
        "importPath": "pages.Criar_bot",
        "description": "pages.Criar_bot",
        "peekOfCode": "userId = None\nif 'LOGGED_IN' in st.session_state and st.session_state['LOGGED_IN'] == True:\n        userId = get_decrypted_cookie(\"__userId__\")\n        show_logout()\n        create_bot_widget()\nelse:\n    switch_page(\"login\")",
        "detail": "pages.Criar_bot",
        "documentation": {}
    },
    {
        "label": "Home_widget",
        "kind": 2,
        "importPath": "pages.Home",
        "description": "pages.Home",
        "peekOfCode": "def Home_widget():\n    with open('style.css') as f:\n        st.markdown(f'<style>{f.read()}</style>', unsafe_allow_html=True)\n    dados = get_user_chatbots(userId)\n    # Carregando os dados do arquivo JSON\n    # with open('chatbot_data.json', 'r') as json_file:\n    #     dados = json.load(json_file)\n    st.title(\"Gest√£o de Chatbots ü§ñ\")\n    st.markdown('<span id=\"button-after-create-bot\"></span>', unsafe_allow_html=True)\n    # Bot√£o para criar um novo chatbot",
        "detail": "pages.Home",
        "documentation": {}
    },
    {
        "label": "userId",
        "kind": 5,
        "importPath": "pages.Home",
        "description": "pages.Home",
        "peekOfCode": "userId = None\nif 'LOGGED_IN' in st.session_state and st.session_state['LOGGED_IN'] == True:\n        userId = get_decrypted_cookie(\"__userId__\")\n        show_logout()                \n        Home_widget()\nelse:\n    print(\"\\n\\nNot logged HOME\\n\\n\")\n    switch_page(\"login\")",
        "detail": "pages.Home",
        "documentation": {}
    },
    {
        "label": "__login__obj",
        "kind": 5,
        "importPath": "login",
        "description": "login",
        "peekOfCode": "__login__obj = __login__(auth_token = \"pk_prod_XNB7MJGSQX4EMBHXE0K17EZE8FCA\", \n                    company_name = \"IFBots\",\n                    width = 200, height = 250, \n                    logout_button_name = 'Sair',\n                    hide_menu_bool = True, \n                    hide_footer_bool = True, \n                    hide_sidebar_itens_bool = True,\n                    lottie_url = 'https://assets2.lottiefiles.com/packages/lf20_jcikwtux.json',\n                    password_reset_url = st.secrets[\"PASSWORD_RESET_URL\"])\nLOGGED_IN = __login__obj.build_login_ui()",
        "detail": "login",
        "documentation": {}
    },
    {
        "label": "LOGGED_IN",
        "kind": 5,
        "importPath": "login",
        "description": "login",
        "peekOfCode": "LOGGED_IN = __login__obj.build_login_ui()\nif LOGGED_IN == True:\n    __login__obj.show_sidebar_itens()\n    switch_page(\"Home\")",
        "detail": "login",
        "documentation": {}
    }
]